---
layout: post
title: 智能指针详解
---
# C++智能指针详解

C++的智能指针是一种用于管理动态内存分配的对象，它们能够自动释放不再使用的内存资源，从而避免内存泄漏。在C++11标准中引入了两种主要的智能指针类型：`std::unique_ptr` 和 `std::shared_ptr`。

## 1. std::unique_ptr

`std::unique_ptr` 是一种独占所有权的智能指针。它不允许复制操作，但可以移动（move）。这意味着只有一个 `std::unique_ptr` 可以指向一个特定的资源，并且当这个 `std::unique_ptr` 被销毁时，它所管理的资源也会被释放。

### 特点
- 不可复制，只能移动。
- 自动清理资源。
- 提供安全的内存管理。

### 示例代码
```cpp
#include <memory>
#include <iostream>

int main() {
    // 创建 unique_ptr
    std::unique_ptr<int> ptr(new int(10));
    
    // 使用 * 和 -> 操作符访问对象
    std::cout << *ptr << std::endl;
    
    // 移动 unique_ptr
    std::unique_ptr<int> ptr2 = std::move(ptr);
    
    // 此时 ptr 已经不再拥有资源，ptr2 拥有资源
    if (ptr) {
        std::cout << "ptr is not null" << std::endl;
    } else {
        std::cout << "ptr is null" << std::endl;
    }
    
    return 0;
}
```

## 2. std::shared_ptr

`std::shared_ptr` 是一种共享所有权的智能指针。多个 `std::shared_ptr` 实例可以共同拥有同一个资源。每个 `std::shared_ptr` 都会维护一个引用计数器，用来跟踪有多少个 `std::shared_ptr` 共享同一个资源。当最后一个 `std::shared_ptr` 被销毁或重置时，资源会被释放。

### 特点
- 支持复制和移动。
- 引用计数机制确保资源安全释放。
- 更灵活，但也可能导致循环引用问题。

### 示例代码
```cpp
#include <memory>
#include <iostream>

int main() {
    // 创建 shared_ptr
    std::shared_ptr<int> ptr1(new int(20));
    
    // 复制 shared_ptr
    std::shared_ptr<int> ptr2 = ptr1;
    
    // 输出引用计数
    std::cout << "Use count of ptr1: " << ptr1.use_count() << std::endl; // 应该输出 2
    
    // 重置 ptr2
    ptr2.reset();
    
    // 现在 ptr2 不再指向任何资源
    if (ptr2) {
        std::cout << "ptr2 is not null" << std::endl;
    } else {
        std::cout << "ptr2 is null" << std::endl;
    }
    
    // 引用计数减少
    std::cout << "Use count of ptr1: " << ptr1.use_count() << std::endl; // 应该输出 1
    
    return 0;
}
```

## 3. 循环引用问题

使用 `std::shared_ptr` 时需要注意循环引用的问题。如果两个或多个 `std::shared_ptr` 相互引用，则会导致它们的引用计数永远不会降到零，从而导致内存泄漏。为了解决这个问题，可以使用 `std::weak_ptr` 来打破循环。

### 示例代码
```cpp
#include <memory>
#include <iostream>

class B; // 前向声明

class A {
public:
    std::shared_ptr<B> b_ptr;
    ~A() { std::cout << "A destroyed" << std::endl; }
};

class B {
public:
    std::weak_ptr<A> a_ptr; // 使用 weak_ptr 避免循环引用
    ~B() { std::cout << "B destroyed" << std::endl; }
};

int main() {
    std::shared_ptr<A> a(new A);
    std::shared_ptr<B> b(new B);
    
    a->b_ptr = b;
    b->a_ptr = a;
    
    return 0;
} // a 和 b 在这里都会被正确销毁
```

## 总结

- **std::unique_ptr**：适用于单一所有权的情况，简单高效。
- **std::shared_ptr**：适用于多所有权的情况，功能强大但需注意循环引用。
- **std::weak_ptr**：辅助 `std::shared_ptr` 解决循环引用问题。

通过合理使用这些智能指针，你可以编写出更安全、更健壮的C++程序。
