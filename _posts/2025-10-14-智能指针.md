
## 右值引用和移动语义

### 起源背景和概念理解
 - 在 C++11 之前，C++ 中只有左值引用（&）。左值引用主要用于绑定左值（具有名称的变量），而右值通常是临时变量，在表达式求值后可能会被丢弃。右值引用（&&）的引入是为了解决对右值的高效处理问题，特别是为实现移动语义铺平道路。
 - 左值（lvalue）是指在内存中具有持久存储的变量，可以出现在赋值语句的左边或右边。例如，int a = 5; 中的 a 是左值。右值（rvalue）通常是临时对象或者字面量等，只能出现在赋值语句的右边。例如，int b = a + 3; 中的 a + 3 是一个右值。
语法形式
右值引用的声明方式是在类型名后加上 && 符号。例如：
int&& right = 10; 这里 right 是一个右值引用，它绑定到右值 10。
对于类类型对象，也可以声明右值引用：
std::string&& str = std::string("hello"); str 绑定到临时创建的 std::string 对象 "hello"。
主要用途
移动语义
移动语义允许将资源从一个对象 “移动” 到另一个对象，而不是进行传统的深拷贝。这对于提高代码性能非常重要，尤其是在处理大型对象（如大容量的容器）时。
例如，考虑一个 vector 对象的拷贝。在没有移动语义的情况下，拷贝构造函数会分配新的内存并逐个元素复制。而有了右值引用，可以编写移动构造函数和移动赋值运算符来 “接管” 右值对象的资源。
示例代码：
```cpp
#include <iostream>
#include <vector>
using namespace std;

class MyVector {
private:
    int* data;
    size_t size;
public:
    MyVector(size_t s) : size(s) {
        data = new int[s];
    }

    // 拷贝构造函数
    MyVector(const MyVector& other) : size(other.size) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) {
            data[i] = other.data[i];
        }
        cout << "Copy constructor called" << endl;
    }

    // 移动构造函数
    MyVector(MyVector&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move constructor called" << endl;
    }

    // 其他成员函数...
};

int main() {
    MyVector vec1(1000000); // 创建一个大 vector
    MyVector vec2 = move(vec1); // 使用移动构造函数
    return 0;
}
```
在这个例子中，当执行 MyVector vec2 = move(vec1); 时，move(vec1) 将 vec1 转换为右值引用，然后调用移动构造函数。移动构造函数接管了 vec1 的资源（data 指针），而 vec1 的资源被置为安全状态（data 置为 nullptr），这样就避免了对 1000000 个元素进行拷贝，大大提高了效率。
完美转发
完美转发用于模板编程中，它允许将参数按照其原始类型（左值或右值）转发给另一个函数。这主要用在函数模板中，使得能够将参数 “透明地” 传递给其他函数。
例如：

```cpp

#include <iostream>
using namespace std;

void func(int&& x) {
    cout << "rvalue reference version, x = " << x << endl;
}

void func(int& x) {
    cout << "lvalue reference version, x = " << x << endl;
}

template<typename T>
void forward_func(T&& x) {
    func(forward<T>(x)); // 完美转发
}

int main() {
    int a = 5;
    forward_func(a); // 调用 lvalue reference version
    forward_func(10); // 调用 rvalue reference version
    return 0;
}
```
在这个例子中，forward_func 模板函数通过 forward<T>(x) 实现完美转发。当传递左值 a 时，forward<T>(x) 保持其为左值引用，并调用对应的左值重载的 func 函数；当传递右值 10 时，forward<T>(x) 将其作为右值引用转发，调用对应的右值重载的 func 函数。
与左值引用的区别
绑定对象的类型不同
左值引用主要用于绑定左值，它提供对变量的别名访问，一般不能直接绑定到右值（除非是 const 修饰的左值引用）。例如：
int& ref1 = 10; 是非法的，因为 10 是右值。
const int& ref2 = 10; 是合法的，这里 const 修饰的左值引用可以绑定到右值。
右值引用主要用于绑定右值，它可以直接绑定到右值。例如：
int&& ref3 = 10; 是合法的。
在函数参数中的作用不同
左值引用作为函数参数主要用于传递左值对象，实现对原对象的引用访问，方便修改原对象等操作。例如，交换两个变量的函数可以使用左值引用作为参数：
cpp
复制
  void swap(int& a, int& b) {
      int temp = a;
      a = b;
      b = temp;
  }
右值引用作为函数参数主要用于接收右值对象，特别是在实现移动语义相关的函数（如移动构造函数、移动赋值运算符）时。例如前面提到的移动构造函数的例子，它接收一个右值引用参数，用于接管资源。
限制和注意事项
右值引用的生命周期问题
绑定到临时对象的右值引用，其临时对象的生命周期会在引用超出作用域时结束。例如：
cpp
复制
  std::string&& str_ref = std::string("hello");
  // 在这个作用域内可以使用 str_ref
} // std::string("hello") 对象在这里被销毁，str_ref 成为悬挂引用
复制
所以要特别注意右值引用的使用范围，避免悬挂引用问题。
不能对右值引用进行取地址操作（特殊情况除外）
一般情况下，对右值引用取地址操作是危险的，因为右值引用可能绑定到临时对象，其地址在对象销毁后就不再有效。例如：
cpp
复制
  int&& right_ref = 10;
  int* ptr = &right_ref; // 这是危险的做法，因为 right_ref 绑定的临时对象在语句结束后就会被销毁
右值引用是 C++11 引入的一个重要特性，它为优化代码性能，特别是处理大型对象和临时对象提供了强大的工具。通过理解和正确使用右值引用，可以编写出更高效、更符合现代 C++ 编程风格的代码。



# 非C++ 11内容

##  static_cast、reinterpret_cast、dynamic_cast 和 const_cast 的区别
在 C++ 里，static_cast、reinterpret_cast、dynamic_cast 和 const_cast 属于显式类型转换操作符，各自有不同的使用场景与安全特性。下面是对它们的总结：

1. static_cast
使用场景：
基本数据类型间的转换，像 int 转 double。
指针和引用在基类与派生类间的转换（包含向上和向下转换）。
枚举类型和整数类型的转换。
void* 指针和其他类型指针的转换。
安全性：部分安全。向上转换（从派生类到基类）是安全的，因为派生类对象包含基类对象的所有成员。但向下转换（从基类到派生类）不安全，因为 static_cast 不会进行运行时类型检查，若基类指针或引用并非指向派生类对象，结果就会是未定义行为。
示例代码：

```cpp

int a = 10;
double b = static_cast<double>(a);  // 基本数据类型转换

class Base { virtual ~Base() {} };
class Derived : public Base {};
Derived d;
Base* b_ptr = static_cast<Base*>(&d);  // 安全的向上转换
```
2. reinterpret_cast
使用场景：
指针和引用之间的低级转换，重新解释对象的位模式。
指针和函数指针之间的转换。
安全性：不安全。reinterpret_cast 不会进行任何类型检查，只是简单地重新解释位模式，这可能会造成未定义行为，尤其是在不同类型的指针间转换时。
示例代码：

```cpp

int a = 10;
int* int_ptr = &a;
double* double_ptr = reinterpret_cast<double*>(int_ptr);  // 不安全的指针转换
```
3. dynamic_cast
使用场景：
运行时安全的向下转换（从基类指针或引用转换为派生类指针或引用）。
检查基类指针或引用是否指向派生类对象。
安全性：安全。dynamic_cast 会进行运行时类型检查（RTTI）。若转换失败，指针转换会返回 nullptr，引用转换会抛出 std::bad_cast 异常。
示例代码：

```cpp

class Base { virtual ~Base() {} };
class Derived : public Base {};
Base* b = new Derived;
Derived* d = dynamic_cast<Derived*>(b);  // 安全的向下转换
if (d) {
    // 转换成功
}
```
4. const_cast
使用场景：
添加或移除变量的 const 或 volatile 属性。
安全性：部分安全。移除 const 属性并修改原本为 const 的对象会导致未定义行为。只有在对象本身并非 const 时，移除 const 属性才是安全的。
示例代码：

```cpp

const int a = 10;
int* b = const_cast<int*>(&a);  // 移除 const 属性，修改 *b 会导致未定义行为

int c = 20;
const int* d = const_cast<const int*>(&c);  // 添加 const 属性，安全
```
总结
| 操作符 | 安全情况 | 原因 | 
|------------------|----------------|----------------------------------------------------------------------| 
| static_cast | 部分安全 | 向上转换安全，向下转换无运行时检查，可能导致未定义行为 |
| reinterpret_cast | 不安全 | 仅重新解释位模式，无类型检查，易产生未定义行为 | 
| dynamic_cast | 安全 | 进行运行时类型检查，转换失败会返回 nullptr 或抛出异常 | 
| const_cast | 部分安全 | 移除 const 属性修改 const 对象会导致未定义行为，其他情况较安全 |

## C++ 中的 `static_cast`

### 概述
`static_cast` 是C++中的一种显式类型转换操作符，用于在<span style="color:red;">编译时进行类型转换</span>。它主要用于基本数据类型之间的转换以及指针和引用之间的转换。`static_cast` <span style="color:red;">不会进行运行时类型检查</span>，因此在使用时需要确保转换的安全性。

### 基本用法

#### 1. 基本数据类型转换
```cpp
int a = 10;
double b = static_cast<double>(a);  // 将 int 转换为 double
```

#### 2. 指针转换

##### 2.1 向上转换（从派生类指针到基类指针）
```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

Derived d;
Base* b_ptr = static_cast<Base*>(&d);  // 向上转换
```

##### 2.2 向下转换（从基类指针到派生类指针）
```cpp
Base* b = new Derived;
Derived* d = static_cast<Derived*>(b);  // 向下转换
// 注意：static_cast 不会进行运行时检查，如果 b 不是指向 Derived 对象的指针，结果未定义
```

#### 3. 引用转换
##### 3.1 向上转换（从派生类引用到基类引用）
```cpp
Derived d;
Base& b_ref = static_cast<Base&>(d);  // 向上转换
```

##### 3.2 向下转换（从基类引用到派生类引用）
```cpp
Base b;
Derived& d_ref = static_cast<Derived&>(b);  // 向下转换
// 注意：static_cast 不会进行运行时检查，如果 b 不是 Derived 对象的引用，结果未定义
```

#### 4. 枚举类型转换
```cpp
enum Color { RED, GREEN, BLUE };
int color_value = static_cast<int>(RED);  // 将枚举类型转换为 int
```

#### 5. void* 指针转换
```cpp
int a = 10;
void* void_ptr = &a;
int* int_ptr = static_cast<int*>(void_ptr);  // 将 void* 转换为 int*
```

### 注意事项

#### 1. 不进行运行时类型检查
`static_cast` 不会进行运行时类型检查，因此在进行向下转换时需要确保转换的安全性。如果转换不安全，结果可能是未定义行为。

#### 2. 仅限于相关类型之间
`static_cast` 只能在相关类型之间进行转换，例如基类和派生类之间，或者基本数据类型之间。

#### 3. 不适用于 const 和 volatile 属性
`static_cast` 不能用于添加或移除 `const` 或 `volatile` 属性。对于这些情况，应使用 `const_cast`。

### 示例代码

```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() {}
    virtual void display() {
        std::cout << "Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        std::cout << "Derived" << std::endl;
    }
};

int main() {
    // 基本数据类型转换
    int a = 10;
    double b = static_cast<double>(a);
    std::cout << "b: " << b << std::endl;

    // 向上转换
    Derived d;
    Base* b_ptr = static_cast<Base*>(&d);
    b_ptr->display();  // 输出: Derived

    // 向下转换
    Base* b = new Derived;
    Derived* d_ptr = static_cast<Derived*>(b);
    d_ptr->display();  // 输出: Derived

    // 枚举类型转换
    enum Color { RED, GREEN, BLUE };
    int color_value = static_cast<int>(RED);
    std::cout << "color_value: " << color_value << std::endl;

    // void* 指针转换
    int c = 20;
    void* void_ptr = &c;
    int* int_ptr = static_cast<int*>(void_ptr);
    std::cout << "*int_ptr: " << *int_ptr << std::endl;

    delete b;
    return 0;
}
```

### 总结
`static_cast` 是C++中一种强大的显式类型转换操作符，适用于基本数据类型之间的转换以及指针和引用之间的转换。使用时需要注意确保转换的安全性，避免未定义行为。



## C++ 中的 dynamic_cast
### 概述
dynamic_cast 是C++中的一种显式类型转换操作符，用于在运行时进行安全的向下转换（从基类指针或引用转换为派生类指针或引用）。dynamic_cast 会进行运行时类型检查，因此在使用时可以确保转换的安全性。
### 基本用法
#### 1. 指针转换
```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

int main() {
    Derived d;
    Base* b_ptr = &d;
    Derived* d_ptr = dynamic_cast<Derived*>(b_ptr);
    if (d_ptr != nullptr) {
        // d_ptr 是指向 Derived 对象的指针
    } else {
        // b_ptr 不是指向 Derived 对象的指针
    }   
}   
```
#### 2. 引用转换
```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void display() {
        std::cout << "Derived" << std::endl;
    }
};

Base b;
try {
    Derived& d_ref = dynamic_cast<Derived&>(b);  // 向下转换
    d_ref.display();  // 输出: Derived
} catch (const std::bad_cast& e) {
    // 转换失败
    std::cout << "Conversion failed: " << e.what() << std::endl;
}
```
### 注意事项
#### 1. 运行时类型检查
dynamic_cast 会进行运行时类型检查，因此在使用时可以确保转换的安全性。如果转换失败，指针转换会返回 nullptr，引用转换会抛出 std::bad_cast 异常。

#### 2. 基类必须有虚函数
dynamic_cast 只能在具有虚函数的类之间进行转换，因为 dynamic_cast 依赖于运行时类型信息（RTTI）。

#### 3. 性能开销
由于 dynamic_cast 进行了运行时类型检查，因此可能会带来一定的性能开销。

### 示例代码
```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() {}
    virtual void display() {
        std::cout << "Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        std::cout << "Derived" << std::endl;
    }
};

int main() {
    // 指针转换
    Base* b = new Derived;
    Derived* d = dynamic_cast<Derived*>(b);  // 向下转换
    if (d) {
        // 成功转换
        d->display();  // 输出: Derived
    } else {
        // 转换失败
        std::cout << "Conversion failed" << std::endl;
    }

    // 引用转换
    Base b_obj;
    try {
        Derived& d_ref = dynamic_cast<Derived&>(b_obj);  // 向下转换
        d_ref.display();  // 输出: Derived
    } catch (const std::bad_cast& e) {
        // 转换失败
        std::cout << "Conversion failed: " << e.what() << std::endl;
    }

    delete b;
    return 0;
}
```
### 总结
dynamic_cast 是C++中一种强大的显式类型转换操作符，用于在运行时进行安全的向下转换。

## C++ 中的 `reinterpret_cast`

### 概述
`reinterpret_cast` 是C++中的一种显式类型转换操作符，用于在编译时进行低级别的重新解释位模式。它主要用于指针和引用之间的转换，以及基本数据类型之间的转换。`reinterpret_cast` 不会进行任何类型检查，因此在使用时需要非常小心，以避免未定义行为。

### 基本用法

#### 1. 指针转换
##### 1.1 基本指针类型转换
```cpp
int a = 10;
int* int_ptr = &a;
double* double_ptr = reinterpret_cast<double*>(int_ptr);  // 重新解释位模式
```

##### 1.2 指针和函数指针之间的转换
```cpp
void (*func_ptr)() = reinterpret_cast<void (*)()>(int_ptr);  // 重新解释位模式
```

#### 2. 引用转换
```cpp
int a = 10;
int& int_ref = a;
double& double_ref = reinterpret_cast<double&>(int_ref);  // 重新解释位模式
```

#### 3. 基本数据类型转换
```cpp
int a = 10;
void* void_ptr = reinterpret_cast<void*>(&a);  // 将 int* 转换为 void*
int* int_ptr = reinterpret_cast<int*>(void_ptr);  // 将 void* 转换为 int*
```

#### 4. 类型转换
```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

Derived d;
Base* b_ptr = reinterpret_cast<Base*>(&d);  // 重新解释位模式
Derived* d_ptr = reinterpret_cast<Derived*>(b_ptr);  // 重新解释位模式
```

### 注意事项

#### 1. 不进行类型检查
`reinterpret_cast` 不会进行任何类型检查，因此在使用时需要确保转换的安全性。如果转换不安全，结果可能是未定义行为。

#### 2. 仅限于相关类型之间
`reinterpret_cast` 只能在相关类型之间进行转换，例如指针和引用之间的转换，或者基本数据类型之间的转换。

#### 3. 避免过度使用
`reinterpret_cast` 应该谨慎使用，因为它可能会导致代码难以理解和维护。只有在绝对必要的情况下才使用 `reinterpret_cast`。

#### 4. 不适用于 const 和 volatile 属性
`reinterpret_cast` 不能用于添加或移除 `const` 或 `volatile` 属性。对于这些情况，应使用 `const_cast`。

### 示例代码

```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() {}
    virtual void display() {
        std::cout << "Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        std::cout << "Derived" << std::endl;
    }
};

int main() {
    // 基本指针类型转换
    int a = 10;
    int* int_ptr = &a;
    double* double_ptr = reinterpret_cast<double*>(int_ptr);  // 重新解释位模式
    std::cout << "*double_ptr: " << *double_ptr << std::endl;  // 未定义行为

    // 指针和函数指针之间的转换
    void (*func_ptr)() = reinterpret_cast<void (*)()>(int_ptr);  // 重新解释位模式
    // func_ptr();  // 未定义行为

    // 引用转换
    int b = 20;
    int& int_ref = b;
    double& double_ref = reinterpret_cast<double&>(int_ref);  // 重新解释位模式
    std::cout << "double_ref: " << double_ref << std::endl;  // 未定义行为

    // 基本数据类型转换
    int c = 30;
    void* void_ptr = reinterpret_cast<void*>(&c);  // 将 int* 转换为 void*
    int* int_ptr2 = reinterpret_cast<int*>(void_ptr);  // 将 void* 转换为 int*
    std::cout << "*int_ptr2: " << *int_ptr2 << std::endl;  // 输出: 30

    // 类型转换
    Derived d;
    Base* b_ptr = reinterpret_cast<Base*>(&d);  // 重新解释位模式
    Derived* d_ptr = reinterpret_cast<Derived*>(b_ptr);  // 重新解释位模式
    d_ptr->display();  // 输出: Derived

    return 0;
}
```

### 总结
`reinterpret_cast` 是C++中一种强大的显式类型转换操作符，用于在编译时进行低级别的重新解释位模式。使用时需要注意确保转换的安全性，避免未定义行为。


## C++ 中的 `const_cast`

### 概述
`const_cast` 是C++中的一种显式类型转换操作符，用于添加或移除变量的 `const` 或 `volatile` 属性。`const_cast` 主要用于在需要修改 `const` 对象时进行转换，或者在需要将 `volatile` 对象传递给不接受 `volatile` 参数的函数时进行转换。`const_cast` 不会进行任何类型检查，因此在使用时需要非常小心，以避免未定义行为。

### 基本用法

#### 1. 移除 `const` 属性
```cpp
const int a = 10;
int* b = const_cast<int*>(&a);  // 移除 const 属性
*b = 20;  // 未定义行为，因为 a 是 const
```

#### 2. 添加 `const` 属性
```cpp
int a = 10;
const int* b = const_cast<const int*>(&a);  // 添加 const 属性
```

#### 3. 移除 `volatile` 属性
```cpp
volatile int a = 10;
int* b = const_cast<int*>(&a);  // 移除 volatile 属性
*b = 20;  // 合法，但需要谨慎使用
```

#### 4. 添加 `volatile` 属性
```cpp
int a = 10;
volatile int* b = const_cast<volatile int*>(&a);  // 添加 volatile 属性
```

### 注意事项

#### 1. 不进行类型检查
`const_cast` 不会进行任何类型检查，因此在使用时需要确保转换的安全性。如果转换不安全，结果可能是未定义行为。

#### 2. 仅限于 `const` 和 `volatile` 属性
`const_cast` 只能用于添加或移除 `const` 和 `volatile` 属性，不能用于其他类型的转换。

#### 3. 避免过度使用
`const_cast` 应该谨慎使用，因为它可能会导致代码难以理解和维护。只有在绝对必要的情况下才使用 `const_cast`。

#### 4. 未定义行为
移除 `const` 属性并修改 `const` 对象会导致未定义行为。因此，在使用 `const_cast` 移除 `const` 属性时，必须确保对象不是 `const` 的。

### 示例代码

```cpp
#include <iostream>

void print(const int& value) {
    std::cout << "Value: " << value << std::endl;
}

int main() {
    // 移除 const 属性
    const int a = 10;
    int* b = const_cast<int*>(&a);  // 移除 const 属性
    // *b = 20;  // 未定义行为，因为 a 是 const

    // 添加 const 属性
    int c = 20;
    const int* d = const_cast<const int*>(&c);  // 添加 const 属性
    print(*d);  // 输出: Value: 20

    // 移除 volatile 属性
    volatile int e = 30;
    int* f = const_cast<int*>(&e);  // 移除 volatile 属性
    *f = 40;  // 合法，但需要谨慎使用
    std::cout << "e: " << e << std::endl;  // 输出: e: 40

    // 添加 volatile 属性
    int g = 50;
    volatile int* h = const_cast<volatile int*>(&g);  // 添加 volatile 属性
    *h = 60;  // 合法
    std::cout << "g: " << g << std::endl;  // 输出: g: 60

    return 0;
}
```

### 总结
`const_cast` 是C++中一种显式类型转换操作符，用于添加或移除变量的 `const` 或 `volatile` 属性。使用时需要注意确保转换的安全性，避免未定义行为。


